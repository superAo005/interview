# [性能优化](https://juejin.cn/post/7274991134362681383#comment)

### [React 性能优化](https://juejin.cn/post/6935584878071119885#comment)
### [面试官问你前端性能优化时，他想问什么？](https://juejin.cn/post/7274991134362681383#comment)(https://juejin.cn/post/7273072756156235834)

## 性能数据采集分为两种

1. #### 实验室性能数据采集

- google 的 lightHouse 帮助我们分析页面的六大属性

[参考文章](https://zhuanlan.zhihu.com/p/617589331)
- First contentful paint 首次内容绘制 (FCP) 10%
  1. 首次内容绘制是指测量页面从开始加载到页面内容（文本、图片、背景图、svg 元素或非白色 canvas 元素）的任何部分在屏幕上完成渲染的时间，是测量加载速度感知的重要指标之一
  2. 首次内容绘制完成渲染时间应控制在 1.8s 以内
  3. 缩小 CSS 体积：写法，压缩 CSS 移除未使用的 CSS
  4. 减少服务器响应时间（TTFB）
  5. 对静态资源使用高效的缓存策略：可缓存资源
  6. 缩小和压缩网络有效负载：缩小（代码），数据压缩（Gzip，Brotli）
- Largest contentful paint 最大内容绘制 (LCP) 25%
  LCP 指标值：LCP <= 2.5s 合格 2.5s < LCP <= 4s 需要优化 LCP > 4s 劣质
   <img> 元素 带有文本或其他行内元素文本的块级元素
- First input delay 首次输入延迟 (FID)
- Time to Interactive 可交互时间 (TTI) 10%
- Total blocking time 总阻塞时间 (TBT) 30%
- Cumulative layout shift 累积布局偏移 (CLS) 25%

2. #### 线上真实数据采集

- 线上接入入 web-vitals 做用户的数据收集
- 接入 sentry 等一些三方 SDK 做性能数据的收集

## 前端性能优化

前端性能优化分为两个方向，一是工程化方向，另一个是代码方向

### 做性能优化的目的-让加载更快，让渲染更快

 1. ### 让加载更快-核心思路是：传输量要小、距离要近、并行传输、资源复用、预先加载。

1 只请求当前需要的资源
异步加载 polylill 路由和组件懒加载
2 缩减资源体积
webpack-打包压缩 代码分割 合理使用 Tree shaking 消除无用的 JS 代码，减少代码体积 http 开启 br 压缩
3 合理利用缓存
cdn 预热 cdn 刷新(大流量) 业务域名 douyin.com cdn-douyin.com
静态资源设置强缓存 webpack 以使用 [contenthash] 占位符来生成文件的哈希值

### 性能优化工具

1 性能检测工具
lighthouse
webpagetest
gzip br
图片格式的优化 压缩 根据不同分辨率展示不同分辨率的图片 webp
尽量控制 cookie 的大小 requst header
3 时序优化
js promise.all
ssr 缓存
prefetch prerender preload

<link rel='dns-prefetch' href=''>

### 怎么减少白屏时间 （代码层面的性能优化）

1. 路由懒加载 组件懒加载
   懒加载前提的实现：ES6 的动态地加载模块——import()
   组件懒加载的使用场景
   1. 该页面的 JS 文件体积大，导致页面打开慢，可以通过组件懒加载进行资源拆分，利用浏览器并行下载资源，提升下载速度（比如首页）
   2. 该组件不是一进入页面就展示，需要一定条件下才触发（比如弹框组件）
   3. 该组件复用性高，很多页面都有引入，利用组件懒加载抽离出该组件，一方面可以很好利用缓存，同时也可以减少页面的 JS 文件大小（比如表格组件、图形组件等）
2. 合理使用 Tree shaking 消除无用的 JS 代码，减少代码体积
   1. tree-shaking 原理
      依赖于 ES6 的模块特性，ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础
      静态分析就是不需要执行代码，就可以从字面量上对代码进行分析。ES6 之前的模块化，比如 CommonJS 是动态加载，只有执行后才知道引用的什么模块，就不能通过静态分析去做优化
   2. tree-shaking 只对使用 export 导出的变量生效
3. 骨架屏优化白屏时长 缩短白屏时间，提升用户体验
4. 长列表虚拟滚动
5. Web Worker 优化长任务
6. requestAnimationFrame 制作动画 该 api 可以解决用 setTimeout/setInterval 制作动画卡顿
7. js 加载方式优化 async、defer 是 script 标签 异步加载 通过 link 的 preload、prefetch 属性来预加载


### 性能优化怎么做
  - #### toC的h5
   1. 网络请求带来的内容等待
      - 资源包预缓存 预加载 资源预埋策略 可以让h5页面的第一次体验更好
      - 放弃浏览器的缓存策略
      - 客户端实现缓存机制 支持动态 静态资源 生成和路由对应的离线路由表
   2. 页面的渲染和 js 性能瓶颈
      - 离线路由 缓存 action通信 webview管理

1. 建立性能数据收集平台，摸底当前性能数据，通过性能打点，将上述整个页面打开过程消耗时间记录下来
2. 分析耗时较长时间段原因，寻找优化点，确定优化目标
3. 开始优化
4. 通过数据收集平台记录优化效果
5. 不断调整优化点和预期目标，循环 2~4 步骤
