/** @license React vundefined
 * react-dom-unstable-fizz.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var React = require('react');

function scheduleWork(callback) {
  setImmediate(callback);
}
function flushBuffered(destination) {
  // If we don't have any more data to send right now.
  // Flush whatever is in the buffer to the wire.
  if (typeof destination.flush === 'function') {
    // http.createServer response have flush(), but it has a different meaning and
    // is deprecated in favor of flushHeaders(). Detect to avoid a warning.
    if (typeof destination.flushHeaders !== 'function') {
      // By convention the Zlib streams provide a flush function for this purpose.
      destination.flush();
    }
  }
}
function beginWriting(destination) {
  // Older Node streams like http.createServer don't have this.
  if (typeof destination.cork === 'function') {
    destination.cork();
  }
}
function writeChunk(destination, buffer) {
  var nodeBuffer = buffer; // close enough

  return destination.write(nodeBuffer);
}
function completeWriting(destination) {
  // Older Node streams like http.createServer don't have this.
  if (typeof destination.uncork === 'function') {
    destination.uncork();
  }
}
function close(destination) {
  destination.end();
}
function convertStringToBuffer(content) {
  return Buffer.from(content, 'utf8');
}

// Allows us to keep track of what we've already written so we can refer back to it.
function createResponseState() {
  return {
    sentCompleteSegmentFunction: false,
    sentCompleteBoundaryFunction: false,
    sentClientRenderFunction: false
  };
} // This object is used to lazily reuse the ID of the first generated node, or assign one.
// We can't assign an ID up front because the node we're attaching it to might already
// have one. So we need to lazily use that if it's available.

function createSuspenseBoundaryID(responseState) {
  return {
    id: null
  };
}

function encodeHTMLIDAttribute(value) {
  // TODO: This needs to be encoded for security purposes.
  return value;
}

function encodeHTMLTextNode(text) {
  // TOOD: This needs to be encoded for security purposes.
  return text;
}

function pushTextInstance(target, text) {
  target.push(convertStringToBuffer(encodeHTMLTextNode(text)));
}
var startTag1 = convertStringToBuffer('<');
var startTag2 = convertStringToBuffer('>');
function pushStartInstance(target, type, props) {
  // TODO: Figure out if it's self closing and everything else.
  target.push(startTag1, convertStringToBuffer(type), startTag2);
}
var endTag1 = convertStringToBuffer('</');
var endTag2 = convertStringToBuffer('>');
function pushEndInstance(target, type, props) {
  // TODO: Figure out if it was self closing.
  target.push(endTag1, convertStringToBuffer(type), endTag2);
} // Structural Nodes
// A placeholder is a node inside a hidden partial tree that can be filled in later, but before
// display. It's never visible to users.

var placeholder1 = convertStringToBuffer('<span id="');
var placeholder2 = convertStringToBuffer('P:');
var placeholder3 = convertStringToBuffer('"></span>');
function writePlaceholder(destination, id) {
  // TODO: This needs to be contextually aware and switch tag since not all parents allow for spans like
  // <select> or <tbody>. E.g. suspending a component that renders a table row.
  writeChunk(destination, placeholder1); // TODO: Use the identifierPrefix option to make the prefix configurable.

  writeChunk(destination, placeholder2);
  var formattedID = convertStringToBuffer(id.toString(16));
  writeChunk(destination, formattedID);
  return writeChunk(destination, placeholder3);
} // Suspense boundaries are encoded as comments.

var startCompletedSuspenseBoundary = convertStringToBuffer('<!--$-->');
var startPendingSuspenseBoundary = convertStringToBuffer('<!--$?-->');
var startClientRenderedSuspenseBoundary = convertStringToBuffer('<!--$!-->');
var endSuspenseBoundary = convertStringToBuffer('<!--/$-->');
function writeStartCompletedSuspenseBoundary(destination, id) {
  return writeChunk(destination, startCompletedSuspenseBoundary);
}
function writeStartPendingSuspenseBoundary(destination, id) {
  return writeChunk(destination, startPendingSuspenseBoundary);
}
function writeStartClientRenderedSuspenseBoundary(destination, id) {
  return writeChunk(destination, startClientRenderedSuspenseBoundary);
}
function writeEndSuspenseBoundary(destination) {
  return writeChunk(destination, endSuspenseBoundary);
}
var startSegment = convertStringToBuffer('<div hidden id="');
var startSegment2 = convertStringToBuffer('S:');
var startSegment3 = convertStringToBuffer('">');
var endSegment = convertStringToBuffer('"></div>');
function writeStartSegment(destination, id) {
  // TODO: What happens with special children like <tr> if they're inserted in a div? Maybe needs contextually aware containers.
  writeChunk(destination, startSegment); // TODO: Use the identifierPrefix option to make the prefix configurable.

  writeChunk(destination, startSegment2);
  var formattedID = convertStringToBuffer(id.toString(16));
  writeChunk(destination, formattedID);
  return writeChunk(destination, startSegment3);
}
function writeEndSegment(destination) {
  return writeChunk(destination, endSegment);
} // Instruction Set
// The following code is the source scripts that we then minify and inline below,
// with renamed function names that we hope don't collide:
// const COMMENT_NODE = 8;
// const SUSPENSE_START_DATA = '$';
// const SUSPENSE_END_DATA = '/$';
// const SUSPENSE_PENDING_START_DATA = '$?';
// const SUSPENSE_FALLBACK_START_DATA = '$!';
//
// function clientRenderBoundary(suspenseBoundaryID) {
//   // Find the fallback's first element.
//   let suspenseNode = document.getElementById(suspenseBoundaryID);
//   if (!suspenseNode) {
//     // The user must have already navigated away from this tree.
//     // E.g. because the parent was hydrated.
//     return;
//   }
//   // Find the boundary around the fallback. This might include text nodes.
//   do {
//     suspenseNode = suspenseNode.previousSibling;
//   } while (
//     suspenseNode.nodeType !== COMMENT_NODE ||
//     suspenseNode.data !== SUSPENSE_PENDING_START_DATA
//   );
//   // Tag it to be client rendered.
//   suspenseNode.data = SUSPENSE_FALLBACK_START_DATA;
//   // Tell React to retry it if the parent already hydrated.
//   if (suspenseNode._reactRetry) {
//     suspenseNode._reactRetry();
//   }
// }
//
// function completeBoundary(suspenseBoundaryID, contentID) {
//   // Find the fallback's first element.
//   let suspenseNode = document.getElementById(suspenseBoundaryID);
//   const contentNode = document.getElementById(contentID);
//   // We'll detach the content node so that regardless of what happens next we don't leave in the tree.
//   // This might also help by not causing recalcing each time we move a child from here to the target.
//   contentNode.parentNode.removeChild(contentNode);
//   if (!suspenseNode) {
//     // The user must have already navigated away from this tree.
//     // E.g. because the parent was hydrated. That's fine there's nothing to do
//     // but we have to make sure that we already deleted the container node.
//     return;
//   }
//   // Find the boundary around the fallback. This might include text nodes.
//   do {
//     suspenseNode = suspenseNode.previousSibling;
//   } while (
//     suspenseNode.nodeType !== COMMENT_NODE ||
//     suspenseNode.data !== SUSPENSE_PENDING_START_DATA
//   );
//
//   // Clear all the existing children. This is complicated because
//   // there can be embedded Suspense boundaries in the fallback.
//   // This is similar to clearSuspenseBoundary in ReactDOMHostConfig.
//   // TOOD: We could avoid this if we never emitted suspense boundaries in fallback trees.
//   // They never hydrate anyway. However, currently we support incrementally loading the fallback.
//   const parentInstance = suspenseNode.parentNode;
//   let node = suspenseNode.nextSibling;
//   let depth = 0;
//   do {
//     if (node && node.nodeType === COMMENT_NODE) {
//       const data = node.data;
//       if (data === SUSPENSE_END_DATA) {
//         if (depth === 0) {
//           break;
//         } else {
//           depth--;
//         }
//       } else if (
//         data === SUSPENSE_START_DATA ||
//         data === SUSPENSE_PENDING_START_DATA ||
//         data === SUSPENSE_FALLBACK_START_DATA
//       ) {
//         depth++;
//       }
//     }
//
//     const nextNode = node.nextSibling;
//     parentInstance.removeChild(node);
//     node = nextNode;
//   } while (node);
//
//   const endOfBoundary = node;
//
//   // Insert all the children from the contentNode between the start and end of suspense boundary.
//   while (contentNode.firstChild) {
//     parentInstance.insertBefore(contentNode.firstChild, endOfBoundary);
//   }
//   suspenseNode.data = SUSPENSE_START_DATA;
//   if (suspenseNode._reactRetry) {
//     suspenseNode._reactRetry();
//   }
// }
//
// function completeSegment(containerID, placeholderID) {
//   const segmentContainer = document.getElementById(containerID);
//   const placeholderNode = document.getElementById(placeholderID);
//   // We always expect both nodes to exist here because, while we might
//   // have navigated away from the main tree, we still expect the detached
//   // tree to exist.
//   segmentContainer.parentNode.removeChild(segmentContainer);
//   while (segmentContainer.firstChild) {
//     placeholderNode.parentNode.insertBefore(
//       segmentContainer.firstChild,
//       placeholderNode,
//     );
//   }
//   placeholderNode.parentNode.removeChild(placeholderNode);
// }

var completeSegmentFunction = 'function $RS(b,f){var a=document.getElementById(b),c=document.getElementById(f);for(a.parentNode.removeChild(a);a.firstChild;)c.parentNode.insertBefore(a.firstChild,c);c.parentNode.removeChild(c)}';
var completeBoundaryFunction = 'function $RC(b,f){var a=document.getElementById(b),c=document.getElementById(f);c.parentNode.removeChild(c);if(a){do a=a.previousSibling;while(8!==a.nodeType||"$?"!==a.data);var h=a.parentNode,d=a.nextSibling,g=0;do{if(d&&8===d.nodeType){var e=d.data;if("/$"===e)if(0===g)break;else g--;else"$"!==e&&"$?"!==e&&"$!"!==e||g++}e=d.nextSibling;h.removeChild(d);d=e}while(d);for(;c.firstChild;)h.insertBefore(c.firstChild,d);a.data="$";a._reactRetry&&a._reactRetry()}}';
var clientRenderFunction = 'function $RX(b){if(b=document.getElementById(b)){do b=b.previousSibling;while(8!==b.nodeType||"$?"!==b.data);b.data="$!";b._reactRetry&&b._reactRetry()}}';
var completeSegmentScript1Full = convertStringToBuffer('<script>' + completeSegmentFunction + ';$RS("S:');
var completeSegmentScript1Partial = convertStringToBuffer('<script>$RS("S:');
var completeSegmentScript2 = convertStringToBuffer('","P:');
var completeSegmentScript3 = convertStringToBuffer('")</script>');
function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
  if (responseState.sentCompleteSegmentFunction) {
    // The first time we write this, we'll need to include the full implementation.
    responseState.sentCompleteSegmentFunction = true;
    writeChunk(destination, completeSegmentScript1Full);
  } else {
    // Future calls can just reuse the same function.
    writeChunk(destination, completeSegmentScript1Partial);
  } // TODO: Use the identifierPrefix option to make the prefix configurable.


  var formattedID = convertStringToBuffer(contentSegmentID.toString(16));
  writeChunk(destination, formattedID);
  writeChunk(destination, completeSegmentScript2);
  writeChunk(destination, formattedID);
  return writeChunk(destination, completeSegmentScript3);
}
var completeBoundaryScript1Full = convertStringToBuffer('<script>' + completeBoundaryFunction + ';$RC("');
var completeBoundaryScript1Partial = convertStringToBuffer('<script>$RC("');
var completeBoundaryScript2 = convertStringToBuffer('","S:');
var completeBoundaryScript3 = convertStringToBuffer('")</script>');
function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
  if (responseState.sentCompleteBoundaryFunction) {
    // The first time we write this, we'll need to include the full implementation.
    responseState.sentCompleteBoundaryFunction = true;
    writeChunk(destination, completeBoundaryScript1Full);
  } else {
    // Future calls can just reuse the same function.
    writeChunk(destination, completeBoundaryScript1Partial);
  } // TODO: Use the identifierPrefix option to make the prefix configurable.


  if (!(boundaryID.id !== null)) {
    {
      throw Error( "An ID must have been assigned before we can complete the boundary." );
    }
  }

  var formattedBoundaryID = convertStringToBuffer(encodeHTMLIDAttribute(boundaryID.id));
  var formattedContentID = convertStringToBuffer(contentSegmentID.toString(16));
  writeChunk(destination, formattedBoundaryID);
  writeChunk(destination, completeBoundaryScript2);
  writeChunk(destination, formattedContentID);
  return writeChunk(destination, completeBoundaryScript3);
}
var clientRenderScript1Full = convertStringToBuffer('<script>' + clientRenderFunction + ';$RX("');
var clientRenderScript1Partial = convertStringToBuffer('<script>$RX("');
var clientRenderScript2 = convertStringToBuffer('")</script>');
function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID) {
  if (responseState.sentClientRenderFunction) {
    // The first time we write this, we'll need to include the full implementation.
    responseState.sentClientRenderFunction = true;
    writeChunk(destination, clientRenderScript1Full);
  } else {
    // Future calls can just reuse the same function.
    writeChunk(destination, clientRenderScript1Partial);
  }

  if (!(boundaryID.id !== null)) {
    {
      throw Error( "An ID must have been assigned before we can complete the boundary." );
    }
  }

  var formattedBoundaryID = convertStringToBuffer(encodeHTMLIDAttribute(boundaryID.id));
  writeChunk(destination, formattedBoundaryID);
  return writeChunk(destination, clientRenderScript2);
}

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
var REACT_FRAGMENT_TYPE = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;
var REACT_CACHE_TYPE = 0xeae4;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
  REACT_CACHE_TYPE = symbolFor('react.cache');
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var PENDING = 0;
var COMPLETED = 1;
var FLUSHED = 2;
var ERRORED = 3;
var BUFFERING = 0;
var FLOWING = 1;
var CLOSED = 2;
function createRequest(children, destination) {
  var pingedWork = [];
  var request = {
    destination: destination,
    responseState: createResponseState(),
    maxBoundarySize: 1024,
    status: BUFFERING,
    nextSegmentId: 0,
    allPendingWork: 0,
    pendingRootWork: 0,
    completedRootSegment: null,
    pingedWork: pingedWork,
    clientRenderedBoundaries: [],
    completedBoundaries: [],
    partialBoundaries: []
  }; // This segment represents the root fallback.

  var rootSegment = createPendingSegment(request, 0, null); // There is no parent so conceptually, we're unblocked to flush this segment.

  rootSegment.parentFlushed = true;
  var rootWork = createSuspendedWork(request, children, null, rootSegment, null);
  pingedWork.push(rootWork);
  return request;
}

function pingSuspendedWork(request, work) {
  var pingedWork = request.pingedWork;
  pingedWork.push(work);

  if (pingedWork.length === 1) {
    scheduleWork(function () {
      return performWork(request);
    });
  }
}

function createSuspenseBoundary(request) {
  return {
    id: createSuspenseBoundaryID(request.responseState),
    rootSegmentID: -1,
    parentFlushed: false,
    pendingWork: 0,
    forceClientRender: false,
    completedSegments: [],
    byteSize: 0
  };
}

function createSuspendedWork(request, node, blockedBoundary, blockedSegment, assignID) {
  request.allPendingWork++;

  if (blockedBoundary === null) {
    request.pendingRootWork++;
  } else {
    blockedBoundary.pendingWork++;
  }

  var work = {
    node: node,
    ping: function () {
      return pingSuspendedWork(request, work);
    },
    blockedBoundary: blockedBoundary,
    blockedSegment: blockedSegment,
    assignID: assignID
  };
  return work;
}

function createPendingSegment(request, index, boundary) {
  return {
    status: PENDING,
    id: -1,
    // lazily assigned later
    index: index,
    parentFlushed: false,
    chunks: [],
    children: [],
    boundary: boundary
  };
}

function fatalError(request, error) {
  // This is called outside error handling code such as if the root errors outside
  // a suspense boundary or if the root suspense boundary's fallback errors.
  // It's also called if React itself or its host configs errors.
  request.status = CLOSED; // TODO: Destroy the stream with an error. We weren't able to complete the root.
}

function renderNode(request, parentBoundary, segment, node) {
  if (typeof node === 'string') {
    pushTextInstance(segment.chunks, node);
    return;
  }

  if (typeof node !== 'object' || !node || node.$$typeof !== REACT_ELEMENT_TYPE) {
    throw new Error('Not yet implemented node type.');
  }

  var element = node;
  var type = element.type;
  var props = element.props;

  if (typeof type === 'function') {
    try {
      var result = type(props);
      renderNode(request, parentBoundary, segment, result);
    } catch (x) {
      if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
        // Something suspended, we'll need to create a new segment and resolve it later.
        var insertionIndex = segment.chunks.length;
        var newSegment = createPendingSegment(request, insertionIndex, null);
        var suspendedWork = createSuspendedWork(request, node, parentBoundary, newSegment, null);
        var ping = suspendedWork.ping;
        x.then(ping, ping); // TODO: Emit place holder
      } else {
        // We can rethrow to terminate the rest of this tree.
        throw x;
      }
    }
  } else if (typeof type === 'string') {
    pushStartInstance(segment.chunks, type);
    renderNode(request, parentBoundary, segment, props.children);
    pushEndInstance(segment.chunks, type);
  } else if (type === REACT_SUSPENSE_TYPE) {
    // Each time we enter a suspense boundary, we split out into a new segment for
    // the fallback so that we can later replace that segment with the content.
    // This also lets us split out the main content even if it doesn't suspend,
    // in case it ends up generating a large subtree of content.
    var fallback = props.fallback;
    var content = props.children;
    var newBoundary = createSuspenseBoundary(request);
    var _insertionIndex = segment.chunks.length; // The children of the boundary segment is actually the fallback.

    var boundarySegment = createPendingSegment(request, _insertionIndex, newBoundary); // We create suspended work for the fallback because we don't want to actually work
    // on it yet in case we finish the main content, so we queue for later.

    var suspendedFallbackWork = createSuspendedWork(request, fallback, parentBoundary, boundarySegment, newBoundary.id // This is the ID we want to give this fallback so we can replace it later.
    ); // TODO: This should be queued at a separate lower priority queue so that we only work
    // on preparing fallbacks if we don't have any more main content to work on.

    request.pingedWork.push(suspendedFallbackWork); // This segment is the actual child content. We can start rendering that immediately.

    var contentRootSegment = createPendingSegment(request, 0, null); // We mark the root segment as having its parent flushed. It's not really flushed but there is
    // no parent segment so there's nothing to wait on.

    contentRootSegment.parentFlushed = true; // TODO: Currently this is running synchronously. We could instead schedule this to pingedWork.
    // I suspect that there might be some efficiency benefits from not creating the suspended work
    // and instead just using the stack if possible. Particularly when we add contexts.

    var contentWork = createSuspendedWork(request, content, newBoundary, contentRootSegment, null);
    retryWork(request, contentWork);
  } else {
    throw new Error('Not yet implemented element type.');
  }
}

function errorWork(request, boundary, segment, error) {
  segment.status = ERRORED;
  request.allPendingWork--;

  if (boundary !== null) {
    boundary.pendingWork--;
  } // Report the error to a global handler.

  if (boundary === null) {
    fatalError(request);
  } else if (!boundary.forceClientRender) {
    boundary.forceClientRender = true; // Regardless of what happens next, this boundary won't be displayed,
    // so we can flush it, if the parent already flushed.

    if (boundary.parentFlushed) {
      // We don't have a preference where in the queue this goes since it's likely
      // to error on the client anyway. However, intentionally client-rendered
      // boundaries should be flushed earlier so that they can start on the client.
      // We reuse the same queue for errors.
      request.clientRenderedBoundaries.push(boundary);
    }
  }
}

function completeWork(request, boundary, segment) {
  segment.status = COMPLETED;
  request.allPendingWork--;

  if (boundary === null) {
    request.pendingRootWork--;

    if (segment.parentFlushed) {
      if (!(request.completedRootSegment === null)) {
        {
          throw Error( "There can only be one root segment. This is a bug in React." );
        }
      }

      request.completedRootSegment = segment;
    }

    return;
  }

  boundary.pendingWork--;

  if (boundary.forceClientRender) {
    // This already errored.
    return;
  }

  if (boundary.pendingWork === 0) {
    // This must have been the last segment we were waiting on. This boundary is now complete.
    if (segment.parentFlushed) {
      // Our parent segment already flushed, so we need to schedule this segment to be emitted.
      boundary.completedSegments.push(segment);
    }

    if (boundary.parentFlushed) {
      // The segment might be part of a segment that didn't flush yet, but if the boundary's
      // parent flushed, we need to schedule the boundary to be emitted.
      request.completedBoundaries.push(boundary);
    }
  } else {
    if (segment.parentFlushed) {
      // Our parent already flushed, so we need to schedule this segment to be emitted.
      var completedSegments = boundary.completedSegments;
      completedSegments.push(segment);

      if (completedSegments.length === 1) {
        // This is the first time since we last flushed that we completed anything.
        // We can schedule this boundary to emit its partially completed segments early
        // in case the parent has already been flushed.
        if (boundary.parentFlushed) {
          request.partialBoundaries.push(boundary);
        }
      }
    }
  }
}

function retryWork(request, work) {
  var segment = work.blockedSegment;
  var boundary = work.blockedBoundary;

  try {
    var node = work.node;

    while (typeof node === 'object' && node !== null && node.$$typeof === REACT_ELEMENT_TYPE && typeof node.type === 'function') {
      // Doing this here lets us reuse this same Segment if the next component
      // also suspends.
      var element = node;
      work.node = node; // TODO: Classes and legacy context etc.

      node = element.type(element.props);
    }

    renderNode(request, boundary, segment, node);
    completeWork(request, boundary, segment);
  } catch (x) {
    if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
      // Something suspended again, let's pick it back up later.
      var ping = work.ping;
      x.then(ping, ping);
    } else {
      errorWork(request, boundary, segment);
    }
  }
}

function performWork(request) {
  if (request.status === CLOSED) {
    return;
  }

  var prevDispatcher = ReactCurrentDispatcher.current;
  ReactCurrentDispatcher.current = Dispatcher;

  try {
    var pingedWork = request.pingedWork;
    var i;

    for (i = 0; i < pingedWork.length; i++) {
      var work = pingedWork[i];
      retryWork(request, work);
    }

    pingedWork.splice(0, i);

    if (request.status === FLOWING) {
      flushCompletedQueues(request);
    }
  } catch (error) {
    fatalError(request);
  } finally {
    ReactCurrentDispatcher.current = prevDispatcher;
  }
}

function flushSubtree(request, destination, segment) {
  segment.parentFlushed = true;

  switch (segment.status) {
    case PENDING:
      {
        // We're emitting a placeholder for this segment to be filled in later.
        // Therefore we'll need to assign it an ID - to refer to it by.
        var segmentID = segment.id = request.nextSegmentId++;
        return writePlaceholder(destination, segmentID);
      }

    case COMPLETED:
      {
        segment.status = FLUSHED;
        var r = true;
        var chunks = segment.chunks;
        var chunkIdx = 0;
        var children = segment.children;

        for (var childIdx = 0; childIdx < children.length; childIdx++) {
          var nextChild = children[childIdx]; // Write all the chunks up until the next child.

          for (; chunkIdx < nextChild.index; chunkIdx++) {
            writeChunk(destination, chunks[chunkIdx]);
          }

          r = flushSegment(request, destination, nextChild);
        } // Finally just write all the remaining chunks


        for (; chunkIdx < chunks.length; chunkIdx++) {
          r = writeChunk(destination, chunks[chunkIdx]);
        }

        return r;
      }

    default:
      {
        {
          {
            throw Error( "Errored or already flushed boundaries should not be flushed again. This is a bug in React." );
          }
        }
      }
  }
}

function flushSegment(request, destination, segment) {
  var boundary = segment.boundary;

  if (boundary === null) {
    // Not a suspense boundary.
    return flushSubtree(request, destination, segment);
  }

  boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to
  // emit the content or the fallback now.

  if (boundary.forceClientRender) {
    // Emit a client rendered suspense boundary wrapper.
    // We never queue the inner boundary so we'll never emit its content or partial segments.
    writeStartClientRenderedSuspenseBoundary(destination, boundary.id); // Flush the fallback.

    flushSubtree(request, destination, segment);
    return writeEndSuspenseBoundary(destination);
  } else if (boundary.pendingWork > 0) {
    // This boundary is still loading. Emit a pending suspense boundary wrapper.
    // Assign an ID to refer to the future content by.
    boundary.rootSegmentID = request.nextSegmentId++;

    if (boundary.completedSegments.length > 0) {
      // If this is at least partially complete, we can queue it to be partially emmitted early.
      request.partialBoundaries.push(boundary);
    }

    writeStartPendingSuspenseBoundary(destination, boundary.id); // Flush the fallback.

    flushSubtree(request, destination, segment);
    return writeEndSuspenseBoundary(destination);
  } else if (boundary.byteSize > request.maxBoundarySize) {
    // This boundary is large and will be emitted separately so that we can progressively show
    // other content. We add it to the queue during the flush because we have to ensure that
    // the parent flushes first so that there's something to inject it into.
    // We also have to make sure that it's emitted into the queue in a deterministic slot.
    // I.e. we can't insert it here when it completes.
    // Assign an ID to refer to the future content by.
    boundary.rootSegmentID = request.nextSegmentId++;
    request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.

    writeStartPendingSuspenseBoundary(destination, boundary.id); // Flush the fallback.

    flushSubtree(request, destination, segment);
    return writeEndSuspenseBoundary(destination);
  } else {
    // We can inline this boundary's content as a complete boundary.
    writeStartCompletedSuspenseBoundary(destination, boundary.id);
    var completedSegments = boundary.completedSegments;

    if (!(completedSegments.length === 1)) {
      {
        throw Error( "A previously unvisited boundary must have exactly one root segment. This is a bug in React." );
      }
    }

    var contentSegment = completedSegments[0];
    flushSegment(request, destination, contentSegment);
    return writeEndSuspenseBoundary(destination);
  }
}

function flushClientRenderedBoundary(request, destination, boundary) {
  return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id);
}

function flushSegmentContainer(request, destination, segment) {
  writeStartSegment(destination, segment.id);
  flushSegment(request, destination, segment);
  return writeEndSegment(destination);
}

function flushCompletedBoundary(request, destination, boundary) {
  var completedSegments = boundary.completedSegments;
  var i = 0;

  for (; i < completedSegments.length; i++) {
    var segment = completedSegments[i];
    flushPartiallyCompletedSegment(request, destination, boundary, segment);
  }

  completedSegments.length = 0;
  return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
}

function flushPartialBoundary(request, destination, boundary) {
  var completedSegments = boundary.completedSegments;
  var i = 0;

  for (; i < completedSegments.length; i++) {
    var segment = completedSegments[i];

    if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
      i++;
      completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority
      // might want to write later.

      return false;
    }
  }

  completedSegments.splice(0, i);
  return true;
}

function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
  if (segment.status === FLUSHED) {
    // We've already flushed this inline.
    return true;
  }

  var segmentID = segment.id;

  if (segmentID === -1) {
    // This segment wasn't previously referred to. This happens at the root of
    // a boundary. We make kind of a leap here and assume this is the root.
    var rootSegmentID = segment.id = boundary.rootSegmentID;

    if (!(rootSegmentID !== -1)) {
      {
        throw Error( "A root segment ID must have been assigned by now. This is a bug in React." );
      }
    }

    return flushSegmentContainer(request, destination, segment);
  } else {
    flushSegmentContainer(request, destination, segment);
    return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
  }
}

var reentrant = false;

function flushCompletedQueues(request) {
  if (reentrant) {
    return;
  }

  reentrant = true;
  var destination = request.destination;
  beginWriting(destination);

  try {
    // The structure of this is to go through each queue one by one and write
    // until the sink tells us to stop. When we should stop, we still finish writing
    // that item fully and then yield. At that point we remove the already completed
    // items up until the point we completed them.
    // TODO: Emit preloading.
    // TODO: It's kind of unfortunate to keep checking this array after we've already
    // emitted the root.
    var completedRootSegment = request.completedRootSegment;

    if (completedRootSegment !== null && request.pendingRootWork === 0) {
      flushSegment(request, destination, completedRootSegment);
      request.completedRootSegment = null;
    } // We emit client rendering instructions for already emitted boundaries first.
    // This is so that we can signal to the client to start client rendering them as
    // soon as possible.


    var clientRenderedBoundaries = request.clientRenderedBoundaries;
    var i;

    for (i = 0; i < clientRenderedBoundaries.length; i++) {
      var boundary = clientRenderedBoundaries[i];

      if (!flushClientRenderedBoundary(request, destination, boundary)) {
        request.status = BUFFERING;
        i++;
        clientRenderedBoundaries.splice(0, i);
        return;
      }
    }

    clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries
    // that are completely done since we can actually show them, than it is to emit
    // any individual segments from a partially complete boundary.

    var completedBoundaries = request.completedBoundaries;

    for (i = 0; i < completedBoundaries.length; i++) {
      var _boundary = completedBoundaries[i];

      if (!flushCompletedBoundary(request, destination, _boundary)) {
        request.status = BUFFERING;
        i++;
        completedBoundaries.splice(0, i);
        return;
      }
    }

    completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before
    // we continue with lower priorities.

    completeWriting(destination);
    beginWriting(destination); // TODO: Here we'll emit data used by hydration.
    // Next we emit any segments of any boundaries that are partially complete
    // but not deeply complete.

    var partialBoundaries = request.partialBoundaries;

    for (i = 0; i < partialBoundaries.length; i++) {
      var _boundary2 = partialBoundaries[i];

      if (!flushPartialBoundary(request, destination, _boundary2)) {
        request.status = BUFFERING;
        i++;
        partialBoundaries.splice(0, i);
        return;
      }
    }

    partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had
    // boundaries added to it in case they were too larged to be inlined.
    // New ones might be added in this loop.

    var largeBoundaries = request.completedBoundaries;

    for (i = 0; i < largeBoundaries.length; i++) {
      var _boundary3 = largeBoundaries[i];

      if (!flushCompletedBoundary(request, destination, _boundary3)) {
        request.status = BUFFERING;
        i++;
        largeBoundaries.splice(0, i);
        return;
      }
    }

    largeBoundaries.splice(0, i);
  } finally {
    reentrant = false;
    completeWriting(destination);
    flushBuffered(destination);

    if (request.allPendingWork === 0 && request.pingedWork.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because
    // either they have pending work or they're complete.
    ) {
        // We're done.
        close(destination);
      }
  }
} // TODO: Expose a way to abort further processing, without closing the connection from the outside.
// This would put all waiting boundaries into client-only mode.


function startWork(request) {
  // TODO: Don't automatically start flowing. Expose an explicit signal. Auto-start once everything is done.
  request.status = FLOWING;
  scheduleWork(function () {
    return performWork(request);
  });
}
function startFlowing(request) {
  if (request.status === CLOSED) {
    return;
  }

  request.status = FLOWING;

  try {
    flushCompletedQueues(request);
  } catch (error) {
    fatalError(request);
  }
}

function notYetImplemented() {
  throw new Error('Not yet implemented.');
}

function unsupportedRefresh() {
  {
    {
      throw Error( "Cache cannot be refreshed during server rendering." );
    }
  }
}

function unsupportedStartTransition() {
  {
    {
      throw Error( "startTransition cannot be called during server rendering." );
    }
  }
}

function noop() {}

var Dispatcher = {
  useMemo: function (nextCreate) {
    return nextCreate();
  },
  useCallback: function (callback) {
    return callback;
  },
  useDebugValue: function () {},
  useDeferredValue: function (value) {
    return value;
  },
  useTransition: function () {
    return [unsupportedStartTransition, false];
  },
  getCacheForType: function (resourceType) {
    throw new Error('Not yet implemented. Should mark as client rendered.');
  },
  readContext: notYetImplemented,
  useContext: notYetImplemented,
  useReducer: notYetImplemented,
  useRef: notYetImplemented,
  useState: notYetImplemented,
  useLayoutEffect: noop,
  // useImperativeHandle is not run in the server environment
  useImperativeHandle: noop,
  // Effects are not run in the server environment.
  useEffect: noop,
  useOpaqueIdentifier: notYetImplemented,
  useMutableSource: notYetImplemented,
  useCacheRefresh: function () {
    return unsupportedRefresh;
  }
};

function createDrainHandler(destination, request) {
  return function () {
    return startFlowing(request);
  };
}

function pipeToNodeWritable(children, destination) {
  var request = createRequest(children, destination);
  destination.on('drain', createDrainHandler(destination, request));
  startWork(request);
}

exports.pipeToNodeWritable = pipeToNodeWritable;
  })();
}
