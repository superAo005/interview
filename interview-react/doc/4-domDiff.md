## 在 React17+中 DOM-DIFF 就是根据老的 fiber 树和最新的 JSX 对比生成新的 fiber 树的过程

## domdiff 讲概念 说用途 理思路 优缺点 先分类 后讲述

### 1. 更新时机

setState reactDom.render()

### 2. 遍历算法 先往二叉树底部走，遇到叶子节点再返回

深度优先遍历 从根节点出发 沿着左子树方向纵向遍历 直到找到叶子节点为止
然后回溯前一个节点 进行右子树节点遍历 直到遍历所有节点
深度优先，有子节点，就遍历子节点，没有子节点，就找兄弟节点，没有兄弟节点，就找叔叔节点，叔叔节点也没有的话，就继续往上找，它爷爷的兄弟，如果一直没找到，就代表所有的更新任务都更新完毕了
广度优先遍历即对二叉树的每一层逐层遍历节点 可能导致生命周期错乱

### 3. 优化策略 react 对 domdiff 算法的优化手段

传统 diff 算法 复杂程度为 O(n\*3) n 表示树的节点总数
分而治之 复杂度为 O（n）分为树 组件 元素

1. 只对同级节点进行对比，如果 DOM 节点跨层级移动，则 React 不会复用 忽略跨层级-比较只会在同层级进行, 不会跨层级比较
2. 组件不同类型的元素会产出不同的结构 ，会销毁老结构，创建新结构
3. 元素同层级可以通过 key 标识移动的元素
4. react 的 diff 算法有个很明显的缺点，对于旧节点的最后子节点挂载到最前面时，整个子节点都需要进行移动。比如：旧 VNode：A、B、C、D；新 VNode：D、A、B、C；
5. React 不能通过双端对比进行 Diff 算法优化是因为目前 Fiber 上没有设置反向链表

### 4. fiber 双链表和双缓冲 fiberNode 和 fiberTree

## React Diff 算法分以下几个步骤

1. 第一轮，从左向右新老节点进行比对查找能复用的旧节点，如果有新老节点比对不成功的，则停止这一轮的比对，并记录了停止的位置
2. 如果第一轮比对，能把所有的新节点都比对完毕，则删除旧节点还没进行比对的节点
3. 如果第一轮的比对，没能将所有的新节点都比对完毕，则继续从第一轮比对停止的位置继续开始循环新节点，拿每一个新节点去老节点里面进行查找，有匹配成功的则复用，没匹配成功的则在协调位置的时候打上 Placement 的标记
4. 在所有新节点比对完毕之后，检查还有没有没进行复用的旧节点，如果有，则全部删除

## domdiff 应用场景

1. 根据 diff 算法的设计原则 应尽量避免跨层级节点移动
2. 设置 key 优化列表 尽量减少组件层级嵌套
3. 设置 scu 和 pure 减少 diff 次数
## vue domdiff
1. 在vue2中使用的是双端diff算法：是一种同时比较新旧两组节点的两个端点的算法（比头、比尾、头尾比、尾头比）。一般情况下，先找出变更后的头部，再对剩下的进行双端diff。
2. 在vue3中使用的是快速diff算法：它借鉴了文本diff算法的预处理思路，先处理新旧两组节点中相同的前置节点和后置节点。当前置节点和后置节点全部处理完毕后，如果无法通过简单的挂载新节点或者卸载已经不存在的节点来更新，则需要根据节点间的索引关系，构造出一个最长递增子序列。最长递增子序列所指向的节点即为不需要移动的节点。


