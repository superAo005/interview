## 前端加载优化
前端性能优化分为两个方向，一是工程化方向，另一个是代码方向
### 做性能优化的目的

1 首屏时间
2 首次可交互时间
3 首次有意义内容渲染
页面性能检测
1 只请求当前需要的资源
异步加载 懒加载 polylill
2 缩减资源体积
打包压缩 webpack
gzip
图片格式的优化 压缩 根据不同分辨率展示不同分辨率的图片 webp
尽量控制 cookie 的大小 requst header
3 时序优化
js promise.all
ssr 缓存
prefetch prerender preload

<link rel='dns-prefetch' href=''>
4 合理利用缓存
 cdn预热 cdn刷新(大流量) 业务域名 douyin.com  cdn-douyin.com
2 如果一端js执行时间过长 怎么去分析
装饰器

### 怎么减少白屏时间 （代码层面 的性能优化）

1. 路由懒加载 组件懒加载
   懒加载前提的实现：ES6 的动态地加载模块——import()
   组件懒加载的使用场景
   1. 该页面的 JS 文件体积大，导致页面打开慢，可以通过组件懒加载进行资源拆分，利用浏览器并行下载资源，提升下载速度（比如首页）
   2. 该组件不是一进入页面就展示，需要一定条件下才触发（比如弹框组件）
   3. 该组件复用性高，很多页面都有引入，利用组件懒加载抽离出该组件，一方面可以很好利用缓存，同时也可以减少页面的 JS 文件大小（比如表格组件、图形组件等）
2. 合理使用 Tree shaking 消除无用的 JS 代码，减少代码体积
   1. tree-shaking 原理
      依赖于 ES6 的模块特性，ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础
      静态分析就是不需要执行代码，就可以从字面量上对代码进行分析。ES6 之前的模块化，比如 CommonJS 是动态加载，只有执行后才知道引用的什么模块，就不能通过静态分析去做优化
   2. tree-shaking 只对使用 export 导出的变量生效
3. 骨架屏优化白屏时长 缩短白屏时间，提升用户体验 
4. 长列表虚拟滚动
5. Web Worker 优化长任务
6. requestAnimationFrame 制作动画 该 api 可以解决用 setTimeout/setInterval 制作动画卡顿
7. js加载方式优化 async、defer 是 script 标签 异步加载 通过 link 的 preload、prefetch 属性来预加载


