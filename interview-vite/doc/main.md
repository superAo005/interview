### unbundle 机制的核心
1. 模块之间的依赖关系的解析由浏览器实现
2. 文件的转换由 dev server 的 middlewares 实现并做缓存
3. 不对源文件做合并捆绑操作
### 热更新
由于 Vite 采用 unbundle 机制，所以 dev server 在监听到文件发生变化以后，只需要通过 ws 连接通知浏览器去重新加载变化的文件，剩下的工作就交给浏览器去做了
热更新，webpack 这边的过程：对修改的文件重新做解析，然后生成新的打包文件；然后通过 ws 连接通知浏览器需要更新哪些文件；浏览器收到通知以后，就去加载新的打包文件，然后更新
vite 的操作: 知道发生变化的文件；通过 ws 连接告诉浏览器那个文件发生变化；浏览器知道哪个文件发生变化，重新请求发生变化的文件；server 对请求的文件做转换；浏览器拿到响应以后更新页面；
### 缺点
unbundle 机制给 Vite 在 dev server 方面获得巨大性能提升的同时，也带来一些负面影响，那就是首屏和懒加载性能的下降
Vite 把需要在 dev server 启动过程中完成的工作，转移到了 dev server 响应浏览器请求的过程中，不可避免的导致首屏性能下降
1. 不对源文件做合并捆绑操作，导致大量的 http 请求
2. dev server 运行期间对源文件做 resolve、load、transform、parse 操作
3. 预构建、二次预构建操作也会阻塞首屏请求，直到预构建完成为止
## vite 优点
### vite服务启动更快
1. webpack打包时必须优先抓取并构建你的整个应用，然后才能提供服务。所以对于大型项目当我们执行npm run serve时通常需要几分钟，即使是热更新甚至也需要几秒
2. Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间
   1. 依赖使用esbuild进行依赖预构建
   2. 源码就是我们代码中写的业务组件.vue,.ts文件等，是esmodule的形式

### vite服务热更新更快
在 Vite 中，HMR 是在原生 ESM 上执行的 

### vite打包构建更快
vite只是devserver启动快和更新快，但是它首屏的时间和页面加载的时间都比webpack更长。最直观的是你控制台能看见端口号，但是页面还在转，因为vite在浏览器请求模块时进行编译转换，vite2.x至少是依赖预构建完了才完全启动Server，首屏快一点。3.x直接异步构建依赖，首屏更慢了，devServer再快都没什么意义，页面并不能直接访问
